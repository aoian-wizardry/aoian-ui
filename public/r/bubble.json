{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "bubble",
  "type": "registry:ui",
  "registryDependencies": [
    "avatar",
    "https://ui.aoian.chat/r/loading"
  ],
  "files": [
    {
      "path": "registry/aoian-ui/bubble.tsx",
      "content": "\"use client\"\n\nimport * as React from \"react\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\nimport {\n  Avatar,\n  AvatarFallback,\n  AvatarImage,\n} from \"@/components/ui/avatar\"\nimport { Loading } from \"@/registry/aoian-ui/loading\"\nimport {useContext} from \"react\";\n\ninterface TypingOption {\n  /**\n   * @default 1\n   */\n  step?: number\n  /**\n   * @default 50\n   */\n  interval?: number\n  /**\n   * @default null\n   */\n  suffix?: React.ReactNode\n}\n\ntype BubbleContextProps = {\n  placement?: \"start\" | \"end\"\n  loading?: boolean\n  typing?: boolean | TypingOption\n  onTypingComplete?: VoidFunction\n  className?: string\n  avatarPlaceholder?: boolean\n  messageRender?: (content: string) => React.ReactNode\n}\n\nconst BubbleContext = React.createContext<BubbleContextProps | null>(null)\n\nfunction useBubble() {\n  const context = React.useContext(BubbleContext)\n  if (context === null) {\n    throw new Error(\"useBubble must be used within a BubbleProvider.\")\n  }\n  return context\n}\n\ninterface BubbleRef {\n  nativeElement: HTMLElement\n}\n\nconst Bubble = React.forwardRef<\n  BubbleRef,\n  React.HTMLAttributes<HTMLDivElement> & BubbleContextProps\n>(\n  (\n    {\n      placement = \"start\",\n      loading,\n      typing,\n      avatarPlaceholder,\n      onTypingComplete,\n      messageRender,\n      className,\n      children,\n      ...props\n    },\n    ref\n  ) => {\n    // ============================= Refs =============================\n    const divRef = React.useRef<HTMLDivElement>(null)\n\n    React.useImperativeHandle(ref, () => ({\n      nativeElement: divRef.current!,\n    }))\n\n    const contextValue = React.useMemo<BubbleContextProps>(\n      () => ({\n        placement,\n        avatarPlaceholder,\n        loading,\n        typing,\n        messageRender,\n        onTypingComplete,\n      }),\n      [\n        placement,\n        loading,\n        typing,\n        onTypingComplete,\n        avatarPlaceholder,\n        messageRender,\n      ]\n    )\n\n    return (\n      <BubbleContext.Provider value={contextValue}>\n        <div\n          className={cn(\n            \"group flex gap-2 data-[placement=end]:flex-row-reverse\",\n            className\n          )}\n          ref={divRef}\n          data-placement={placement}\n          {...props}\n        >\n          {avatarPlaceholder && <BubbleAvatar placeholder />}\n          {children}\n        </div>\n      </BubbleContext.Provider>\n    )\n  }\n)\nBubble.displayName = \"Bubble\"\n\ntype BubbleAvatarProps = {\n  className?: string\n  textClassName?: string\n  triggerClassName?: string\n  src?: string\n  alt?: string\n  loading?: boolean\n  children?: React.ReactNode\n  placeholder?: boolean\n}\nconst BubbleAvatar = React.forwardRef<\n  React.ElementRef<typeof Avatar>,\n  BubbleAvatarProps\n>(\n  (\n    {\n      textClassName,\n      triggerClassName,\n      className,\n      src,\n      alt,\n      placeholder,\n      loading,\n      children,\n    },\n    ref\n  ) => {\n    if (placeholder) {\n      return <div className={cn(\"invisible h-8 w-8 shrink-0\", className)}></div>\n    }\n    return (\n      <Avatar className={cn(\"h-8 w-8 shrink-0\", className)} ref={ref}>\n        <AvatarImage src={src} alt={alt ?? \"@aoian\"} />\n        <AvatarFallback\n          className={cn(\n            \"bg-purple-400 text-sm font-medium text-white\",\n            textClassName\n          )}\n        >\n          {children}\n        </AvatarFallback>\n        {loading && (\n          <AvatarTrigger\n            className={cn(\"h-4 w-4 [&>svg]:size-2.5\", triggerClassName)}\n          >\n            <Loading size=\"sm\" className=\"gap-px\" itemClassName=\"bg-white\" />\n          </AvatarTrigger>\n        )}\n      </Avatar>\n    )\n  }\n)\nBubbleAvatar.displayName = \"BubbleAvatar\"\n\nconst BubbleHeader = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => {\n  return (\n    <div\n      ref={ref}\n      className={cn(\"text-chat-foreground mb-1 text-sm\", className)}\n      {...props}\n    />\n  )\n})\nBubbleHeader.displayName = \"BubbleHeader\"\n\nconst BubbleFooter = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => {\n  return <div ref={ref} className={cn(\"mt-2 text-sm\", className)} {...props} />\n})\nBubbleFooter.displayName = \"BubbleFooter\"\n\nconst BubbleWrapper = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => {\n  return (\n    <div\n      ref={ref}\n      className={cn(\"flex min-w-0 max-w-full flex-col\", className)}\n      {...props}\n    />\n  )\n})\nBubbleWrapper.displayName = \"BubbleWrapper\"\n\nconst bubbleContentVariants = cva(\"text-chat-foreground px-4 py-3 text-sm\", {\n  variants: {\n    variant: {\n      filled: \"bg-chat-bubble text-chat-bubble-foreground\",\n      outlined: \"border-chat-bubble-border border\",\n      shadow: \"dark:bg-chat-bubble shadow\",\n      borderless: \"border-none px-0 py-0\",\n    },\n    shape: {\n      default: \"rounded-xl\",\n      round: \"rounded-[calc(20px/2+12px)]\",\n      corner: \"rounded-xl\",\n    },\n  },\n  defaultVariants: {\n    variant: \"filled\",\n    shape: \"default\",\n  },\n})\n\nexport interface BubbleContentProps\n  extends React.HTMLAttributes<HTMLDivElement>,\n    VariantProps<typeof bubbleContentVariants> {\n  loading?: boolean\n}\n\nconst BubbleContent = React.forwardRef<HTMLDivElement, BubbleContentProps>(\n  ({ className, variant, shape, loading, children, ...props }, ref) => {\n    const { placement, typing, onTypingComplete, messageRender } = useBubble()\n    const [typingEnabled, typingStep, typingInterval, customSuffix] =\n      useTypingConfig(typing)\n     const { onUpdate } =  useContext(BubbleListContext)\n    // ============================ Typing ============================\n    const [typedContent, isTyping] = useTypedEffect(\n      children,\n      typingEnabled,\n      typingStep,\n      typingInterval\n    )\n\n    React.useEffect(() => {\n      onUpdate?.()\n    }, [typedContent])\n\n    const triggerTypingCompleteRef = React.useRef(false)\n    React.useEffect(() => {\n      if (!isTyping && !loading) {\n        // StrictMode will trigger this twice,\n        // So we need a flag to avoid that\n        if (!triggerTypingCompleteRef.current) {\n          triggerTypingCompleteRef.current = true\n          onTypingComplete?.()\n        }\n      } else {\n        triggerTypingCompleteRef.current = false\n      }\n    }, [isTyping, loading])\n\n    // =========================== Content ============================\n    const mergedContent = messageRender\n      ? messageRender(typedContent as any)\n      : typedContent\n\n    return (\n      <div\n        ref={ref}\n        className={cn(\n          bubbleContentVariants({ variant, shape }),\n          shape === \"corner\" && placement === \"end\" && \"rounded-tr-sm\",\n          shape === \"corner\" && placement === \"start\" && \"rounded-tl-sm\",\n          className\n        )}\n        {...props}\n      >\n        {loading ? (\n          <Loading itemClassName=\"bg-chat-bubble-foreground\" className=\"h-5\" />\n        ) : (\n          <>\n            {mergedContent}\n            {isTyping && customSuffix}\n          </>\n        )}\n      </div>\n    )\n  }\n)\nBubbleContent.displayName = \"BubbleContent\"\n\n// ============================= BubbleList =============================\ninterface BubbleListRef {\n  nativeElement: HTMLDivElement\n  scrollTo: (info: {\n    offset?: number\n    key?: string | number\n    behavior?: ScrollBehavior\n    block?: ScrollLogicalPosition\n  }) => void\n}\n\ntype BubbleDataType = BubbleContextProps & {\n  content?: React.ReactNode\n  key?: string | number\n  role?: string\n  header?: React.ReactNode;\n  footer?: React.ReactNode;\n  avatar?: React.ReactElement;\n  variant?: 'filled' | 'borderless' | 'outlined' | 'shadow';\n  shape?: 'round' | 'corner';\n}\n\ntype RoleType = Partial<Omit<BubbleDataType, 'content' | 'key' | 'role'>>\n\ntype RolesType =\n  | Record<string, RoleType>\n  | ((bubbleDataP: BubbleDataType, index: number) => RoleType)\n\ninterface BubbleListProps extends React.HTMLAttributes<HTMLDivElement> {\n  className?: string\n  items?: BubbleDataType[]\n  autoScroll?: boolean\n  roles?: RolesType\n}\n\nconst TOLERANCE = 1\n\ninterface BubbleListContextProps {\n  onUpdate?: VoidFunction\n}\n\nconst BubbleListContext = React.createContext<BubbleListContextProps>({})\n\nconst BubbleList = React.forwardRef<BubbleListRef, BubbleListProps>(\n  ({ className, items, autoScroll = true, roles, ...props }, ref) => {\n    // ============================= Refs =============================\n    const listRef = React.useRef<HTMLDivElement>(null)\n\n    const bubbleRefs = React.useRef<Record<string, BubbleRef>>({})\n\n    // ============================ Typing ============================\n    const [initialized, setInitialized] = React.useState(false)\n\n    React.useEffect(() => {\n      setInitialized(true)\n      return () => {\n        setInitialized(false)\n      }\n    }, [])\n\n    // ============================= Data =============================\n    const mergedData = useListData(items, roles)\n    const [displayData, onTypingComplete] = useDisplayData(mergedData)\n\n    // ============================ Scroll ============================\n    // Is current scrollTop at the end. User scroll will make this false.\n    const [scrollReachEnd, setScrollReachEnd] = React.useState(true)\n\n    const [updateCount, setUpdateCount] = React.useState(0)\n\n    const onInternalScroll: React.UIEventHandler<HTMLDivElement> = (e) => {\n      const target = e.target as HTMLElement\n\n      setScrollReachEnd(\n        target.scrollHeight -\n          Math.abs(target.scrollTop) -\n          target.clientHeight <=\n          TOLERANCE\n      )\n    }\n\n    React.useEffect(() => {\n      if (autoScroll && listRef.current && scrollReachEnd) {\n        listRef.current.scrollTo({\n          top: listRef.current.scrollHeight,\n        })\n      }\n    }, [updateCount])\n\n    // Always scroll to bottom when data change\n    React.useEffect(() => {\n      if (autoScroll) {\n\n        // New date come, the origin last one is the second last one\n        const lastItemKey = displayData[displayData.length - 2]?.key\n        const bubbleInst = bubbleRefs.current[lastItemKey!]\n\n\n        // Auto scroll if last 2 item is visible\n        if (bubbleInst) {\n          const { nativeElement } = bubbleInst\n          const { top, bottom } = nativeElement.getBoundingClientRect()\n          const { top: listTop, bottom: listBottom } =\n            listRef.current!.getBoundingClientRect()\n\n\n          const isVisible = top < listBottom && bottom > listTop\n          if (isVisible) {\n            setUpdateCount((c) => c + 1)\n            setScrollReachEnd(true)\n          }\n        }\n      }\n    }, [displayData.length])\n\n    // ========================== Outer Ref ===========================\n    React.useImperativeHandle(ref, () => ({\n      nativeElement: listRef.current!,\n      scrollTo: ({ key, offset, behavior = \"smooth\", block }) => {\n        if (typeof offset === \"number\") {\n          // Offset scroll\n          listRef.current!.scrollTo({\n            top: offset,\n            behavior,\n          })\n        } else if (key !== undefined) {\n          // Key scroll\n          const bubbleInst = bubbleRefs.current[key]\n\n          if (bubbleInst) {\n            // Block current auto scrolling\n            const index = displayData.findIndex(\n              (dataItem) => dataItem.key === key\n            )\n            setScrollReachEnd(index === displayData.length - 1)\n\n            // Do native scroll\n            bubbleInst.nativeElement.scrollIntoView({\n              behavior,\n              block,\n            })\n          }\n        }\n      },\n    }))\n\n    // =========================== Context ============================\n    // When bubble content update, we try to trigger `autoScroll` for sync\n    const onBubbleUpdate = useEvent(() => {\n      if (autoScroll) {\n        setUpdateCount((c) => c + 1)\n      }\n    })\n\n    const context = React.useMemo(\n      () => ({\n        onUpdate: onBubbleUpdate,\n      }),\n      []\n    )\n\n    return (\n      <BubbleListContext.Provider value={context}>\n        <div\n          {...props}\n          ref={listRef}\n          className={cn(\"flex flex-col gap-4 overflow-y-auto\", className)}\n          onScroll={onInternalScroll}\n        >\n          {displayData.map(({ key, content, loading, avatar, header, footer, shape, variant, ...bubble }) => (\n            <Bubble\n              {...bubble}\n              key={key}\n              ref={(node) => {\n                if (node) {\n                  bubbleRefs.current[key] = node\n                } else {\n                  delete bubbleRefs.current[key]\n                }\n              }}\n              typing={initialized ? bubble.typing : false}\n              onTypingComplete={() => {\n                bubble.onTypingComplete?.()\n                onTypingComplete(key)\n              }}\n            >\n              <>\n              {avatar}\n              <BubbleWrapper>\n                {header}\n                <BubbleContent shape={shape} variant={variant} loading={loading}>{content}</BubbleContent>\n                {footer}\n              </BubbleWrapper>\n              </>\n            </Bubble>\n          ))}\n        </div>\n      </BubbleListContext.Provider>\n    )\n  }\n)\nBubbleList.displayName = \"BubbleList\"\n\n// ============================= Hooks =============================\nfunction isString(str: any): str is string {\n  return typeof str === \"string\"\n}\n\nfunction useEvent<T extends Function>(callback: T): T {\n  const fnRef = React.useRef<any>()\n  fnRef.current = callback\n\n  const memoFn = React.useCallback<T>(\n    ((...args: any) => fnRef.current?.(...args)) as any,\n    []\n  )\n\n  return memoFn\n}\n\n/**\n * Return typed content and typing status when typing is enabled.\n * Or return content directly.\n */\nfunction useTypedEffect(\n  content: React.ReactNode | object,\n  typingEnabled: boolean,\n  typingStep: number,\n  typingInterval: number\n): [typedContent: React.ReactNode | object, isTyping: boolean] {\n  const [prevContent, setPrevContent] = React.useState<\n    React.ReactNode | object\n  >(\"\")\n  const [typingIndex, setTypingIndex] = React.useState<number>(1)\n\n  const mergedTypingEnabled = typingEnabled && isString(content)\n\n  // Reset typing index when content changed\n  React.useLayoutEffect(() => {\n    setPrevContent(content)\n    if (!mergedTypingEnabled && isString(content)) {\n      setTypingIndex(content.length)\n    } else if (\n      isString(content) &&\n      isString(prevContent) &&\n      content.indexOf(prevContent) !== 0\n    ) {\n      setTypingIndex(1)\n    }\n  }, [content])\n\n  // Start typing\n  React.useEffect(() => {\n    if (mergedTypingEnabled && typingIndex < content.length) {\n      const id = setTimeout(() => {\n        setTypingIndex((prev) => prev + typingStep)\n      }, typingInterval)\n\n      return () => {\n        clearTimeout(id)\n      }\n    }\n  }, [typingIndex, typingEnabled, content])\n\n  const mergedTypingContent = mergedTypingEnabled\n    ? content.slice(0, typingIndex)\n    : content\n\n  return [\n    mergedTypingContent,\n    mergedTypingEnabled && typingIndex < content.length,\n  ]\n}\n\nfunction useTypingConfig(typing?: boolean | TypingOption) {\n  return React.useMemo<\n    [\n      enableTyping: boolean,\n      step: number,\n      interval: number,\n      suffix: React.ReactNode\n    ]\n  >(() => {\n    if (!typing) {\n      return [false, 0, 0, null]\n    }\n\n    let baseConfig: Required<TypingOption> = {\n      step: 1,\n      interval: 50,\n      // set default suffix is empty\n      suffix: null,\n    }\n\n    if (typeof typing === \"object\") {\n      baseConfig = { ...baseConfig, ...typing }\n    }\n\n    return [true, baseConfig.step, baseConfig.interval, baseConfig.suffix]\n  }, [typing])\n}\n\nfunction useListData(\n  items: BubbleListProps[\"items\"],\n  roles?: BubbleListProps[\"roles\"]\n) {\n  const getRoleBubbleProps = React.useCallback(\n    (bubble: BubbleDataType, index: number): Partial<BubbleContextProps> => {\n      if (typeof roles === \"function\") {\n        return roles(bubble, index)\n      }\n\n      if (roles) {\n        return roles[bubble.role!] || {}\n      }\n\n      return {}\n    },\n    [roles]\n  )\n\n  return React.useMemo(\n    () =>\n      (items || []).map((bubbleData, i) => {\n        const mergedKey = bubbleData.key ?? `preset_${i}`\n\n        return {\n          ...getRoleBubbleProps(bubbleData, i),\n          ...bubbleData,\n          key: mergedKey,\n        }\n      }),\n    [items, getRoleBubbleProps]\n  )\n}\n\ntype ListItemType = ReturnType<typeof useListData>[number]\n\nfunction useDisplayData(items: ListItemType[]) {\n  const [displayCount, setDisplayCount] = React.useState(items.length)\n\n  const displayList = React.useMemo(\n    () => items.slice(0, displayCount),\n    [items, displayCount]\n  )\n\n  const displayListLastKey = React.useMemo(() => {\n    const lastItem = displayList[displayList.length - 1]\n    return lastItem ? lastItem.key : null\n  }, [displayList])\n\n  // When `items` changed, we replaced with latest one\n  React.useEffect(() => {\n    if (\n      displayList.length &&\n      displayList.every((item, index) => item.key === items[index]?.key)\n    ) {\n      return\n    }\n\n    if (displayList.length === 0) {\n      setDisplayCount(1)\n    } else {\n      // Find diff index\n      for (let i = 0; i < displayList.length; i += 1) {\n        if (displayList[i].key !== items[i]?.key) {\n          setDisplayCount(i)\n          break\n        }\n      }\n    }\n  }, [items])\n\n  // Continue to show if last one finished typing\n  const onTypingComplete = useEvent((key: string | number) => {\n    if (key === displayListLastKey) {\n      setDisplayCount(displayCount + 1)\n    }\n  })\n\n  return [displayList, onTypingComplete] as const\n}\n\nconst AvatarTrigger = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\">\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\n      \"absolute bg-[#e3b341] -bottom-1 -right-1 inline-flex h-5 w-5 items-center justify-center rounded-full [&>svg]:size-3\",\n      className\n    )}\n    {...props}\n  />\n))\nAvatarTrigger.displayName = \"AvatarTrigger\"\n\nexport {\n  Bubble,\n  BubbleList,\n  BubbleAvatar,\n  BubbleHeader,\n  BubbleWrapper,\n  BubbleContent,\n  BubbleFooter,\n  useBubble,\n  type BubbleListProps,\n  type BubbleListRef,\n}\n",
      "type": "registry:ui"
    }
  ]
}