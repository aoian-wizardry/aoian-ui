{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "bubble",
  "type": "registry:component",
  "title": "Bubble",
  "description": "A bubble component for chat.",
  "registryDependencies": [
    "avatar",
    "https://ui.aoian.chat/r/loading",
    "https://ui.aoian.chat/r/use-event"
  ],
  "files": [
    {
      "path": "registry/aoian-ui/bubble/bubble.tsx",
      "content": "\"use client\"\n\nimport * as React from \"react\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Avatar, AvatarFallback, AvatarImage } from \"@/components/ui/avatar\"\nimport { useBubbleList } from \"@/components/aoian-ui/bubble/bubble-list\"\nimport type { BubbleProps, BubbleRef } from \"@/components/aoian-ui/bubble/types\"\nimport { useTypedEffect } from \"@/components/aoian-ui/hooks/use-typed-effect\"\nimport { useTypingConfig } from \"@/components/aoian-ui/hooks/use-typing-config\"\nimport { Loading } from \"@/components/aoian-ui/loading\"\n\nconst BubbleContext = React.createContext<BubbleProps | null>(null)\n\nfunction useBubble() {\n  const context = React.useContext(BubbleContext)\n  if (context === null) {\n    throw new Error(\"useBubble must be used within a BubbleProvider.\")\n  }\n  return context\n}\n\nconst Bubble = React.forwardRef<\n  BubbleRef,\n  React.HTMLAttributes<HTMLDivElement> & BubbleProps\n>(\n  (\n    {\n      placement = \"start\",\n      loading,\n      typing,\n      avatarPlaceholder,\n      onTypingComplete,\n      messageRender,\n      className,\n      children,\n      ...props\n    },\n    ref\n  ) => {\n    // ============================= Refs =============================\n    const divRef = React.useRef<HTMLDivElement>(null)\n\n    React.useImperativeHandle(ref, () => ({\n      nativeElement: divRef.current!,\n    }))\n\n    const contextValue = React.useMemo<BubbleProps>(\n      () => ({\n        placement,\n        avatarPlaceholder,\n        loading,\n        typing,\n        messageRender,\n        onTypingComplete,\n      }),\n      [\n        placement,\n        loading,\n        typing,\n        onTypingComplete,\n        avatarPlaceholder,\n        messageRender,\n      ]\n    )\n\n    return (\n      <BubbleContext.Provider value={contextValue}>\n        <div\n          className={cn(\n            \"group flex gap-2 data-[placement=end]:flex-row-reverse\",\n            className\n          )}\n          ref={divRef}\n          data-placement={placement}\n          {...props}\n        >\n          {avatarPlaceholder && <BubbleAvatar placeholder />}\n          {children}\n        </div>\n      </BubbleContext.Provider>\n    )\n  }\n)\nBubble.displayName = \"Bubble\"\n\ntype BubbleAvatarProps = {\n  className?: string\n  textClassName?: string\n  triggerClassName?: string\n  src?: string\n  alt?: string\n  loading?: boolean\n  children?: React.ReactNode\n  placeholder?: boolean\n}\nconst BubbleAvatar = React.forwardRef<\n  React.ElementRef<typeof Avatar>,\n  BubbleAvatarProps\n>(\n  (\n    {\n      textClassName,\n      triggerClassName,\n      className,\n      src,\n      alt,\n      placeholder,\n      loading,\n      children,\n    },\n    ref\n  ) => {\n    if (placeholder) {\n      return <div className={cn(\"invisible h-8 w-8 shrink-0\", className)}></div>\n    }\n    return (\n      <Avatar className={cn(\"h-8 w-8 shrink-0\", className)} ref={ref}>\n        <AvatarImage src={src} alt={alt ?? \"@aoian\"} />\n        <AvatarFallback\n          className={cn(\n            \"bg-purple-400 text-sm font-medium text-white\",\n            textClassName\n          )}\n        >\n          {children}\n        </AvatarFallback>\n        {loading && (\n          <AvatarTrigger className={cn(\"[&>svg]:size-4\", triggerClassName)}>\n            <Loading size=\"sm\" className=\"gap-px\" itemClassName=\"bg-white\" />\n          </AvatarTrigger>\n        )}\n      </Avatar>\n    )\n  }\n)\nBubbleAvatar.displayName = \"BubbleAvatar\"\n\nconst BubbleHeader = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => {\n  return (\n    <div\n      ref={ref}\n      className={cn(\"mb-1 text-sm text-accent-foreground\", className)}\n      {...props}\n    />\n  )\n})\nBubbleHeader.displayName = \"BubbleHeader\"\n\nconst BubbleFooter = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => {\n  return <div ref={ref} className={cn(\"mt-2 text-sm\", className)} {...props} />\n})\nBubbleFooter.displayName = \"BubbleFooter\"\n\nconst BubbleWrapper = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => {\n  return (\n    <div\n      ref={ref}\n      className={cn(\"flex min-w-0 max-w-full flex-col\", className)}\n      {...props}\n    />\n  )\n})\nBubbleWrapper.displayName = \"BubbleWrapper\"\n\nconst bubbleContentVariants = cva(\"px-4 py-3 text-sm\", {\n  variants: {\n    variant: {\n      filled: \"bg-muted text-foreground\",\n      outlined: \"border-border border\",\n      shadow: \"dark:bg-muted shadow\",\n      borderless: \"border-none px-0 py-0\",\n    },\n    shape: {\n      default: \"rounded-xl\",\n      round: \"rounded-[calc(20px/2+12px)]\",\n      corner: \"rounded-xl\",\n    },\n  },\n  defaultVariants: {\n    variant: \"filled\",\n    shape: \"default\",\n  },\n})\n\nexport interface BubbleContentProps\n  extends React.HTMLAttributes<HTMLDivElement>,\n    VariantProps<typeof bubbleContentVariants> {\n  loading?: boolean\n}\n\nconst BubbleContent = React.forwardRef<HTMLDivElement, BubbleContentProps>(\n  ({ className, variant, shape, loading, children, ...props }, ref) => {\n    const { placement, typing, onTypingComplete, messageRender } = useBubble()\n    const [typingEnabled, typingStep, typingInterval, customSuffix] =\n      useTypingConfig(typing)\n    const { onUpdate } = useBubbleList()\n    // ============================ Typing ============================\n    const [typedContent, isTyping] = useTypedEffect(\n      children,\n      typingEnabled,\n      typingStep,\n      typingInterval\n    )\n\n    React.useEffect(() => {\n      onUpdate?.()\n    }, [typedContent])\n\n    const triggerTypingCompleteRef = React.useRef(false)\n    React.useEffect(() => {\n      if (!isTyping && !loading) {\n        // StrictMode will trigger this twice,\n        // So we need a flag to avoid that\n        if (!triggerTypingCompleteRef.current) {\n          triggerTypingCompleteRef.current = true\n          onTypingComplete?.()\n        }\n      } else {\n        triggerTypingCompleteRef.current = false\n      }\n    }, [isTyping, loading])\n\n    // =========================== Content ============================\n    const mergedContent = messageRender\n      ? messageRender(typedContent as any)\n      : typedContent\n\n    return (\n      <div\n        ref={ref}\n        className={cn(\n          bubbleContentVariants({ variant, shape }),\n          shape === \"corner\" && placement === \"end\" && \"rounded-tr-sm\",\n          shape === \"corner\" && placement === \"start\" && \"rounded-tl-sm\",\n          className\n        )}\n        {...props}\n      >\n        {loading ? (\n          <Loading className=\"h-5\" />\n        ) : (\n          <>\n            {mergedContent}\n            {isTyping && customSuffix}\n          </>\n        )}\n      </div>\n    )\n  }\n)\nBubbleContent.displayName = \"BubbleContent\"\n\nconst AvatarTrigger = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentProps<\"div\">\n>(({ className, ...props }, ref) => (\n  <div\n    ref={ref}\n    className={cn(\n      \"absolute bottom-0 left-0 right-0 top-0 m-auto flex h-full w-full items-center justify-center rounded-full bg-black/60 [&>svg]:size-3\",\n      className\n    )}\n    {...props}\n  />\n))\nAvatarTrigger.displayName = \"AvatarTrigger\"\n\nexport {\n  Bubble,\n  BubbleAvatar,\n  BubbleHeader,\n  BubbleWrapper,\n  BubbleContent,\n  BubbleFooter,\n  useBubble,\n}\n",
      "type": "registry:component",
      "target": "components/aoian-ui/bubble/bubble.tsx"
    },
    {
      "path": "registry/aoian-ui/bubble/bubble-list.tsx",
      "content": "import * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\nimport {\n  Bubble,\n  BubbleContent,\n  BubbleWrapper,\n} from \"@/components/aoian-ui/bubble/bubble\"\nimport type {\n  BubbleListProps,\n  BubbleListRef,\n  BubbleRef,\n} from \"@/components/aoian-ui/bubble/types\"\nimport { useDisplayData } from \"@/components/aoian-ui/hooks/use-display-data\"\nimport { useEvent } from \"@/components/aoian-ui/hooks/use-event\"\nimport { useListData } from \"@/components/aoian-ui/hooks/use-list-data\"\n\ninterface BubbleListContextProps {\n  onUpdate?: VoidFunction\n}\n\nconst TOLERANCE = 1\n\nconst BubbleListContext = React.createContext<BubbleListContextProps>({})\n\nfunction useBubbleList() {\n  const context = React.useContext(BubbleListContext)\n  if (context === null) {\n    throw new Error(\"useBubbleList must be used within a BubbleListProvider.\")\n  }\n  return context\n}\n\nconst BubbleList = React.forwardRef<BubbleListRef, BubbleListProps>(\n  ({ className, items, autoScroll = true, roles, ...props }, ref) => {\n    // ============================= Refs =============================\n    const listRef = React.useRef<HTMLDivElement>(null)\n\n    const bubbleRefs = React.useRef<Record<string, BubbleRef>>({})\n\n    // ============================ Typing ============================\n    const [initialized, setInitialized] = React.useState(false)\n\n    React.useEffect(() => {\n      setInitialized(true)\n      return () => {\n        setInitialized(false)\n      }\n    }, [])\n\n    // ============================= Data =============================\n    const mergedData = useListData(items, roles)\n    const [displayData, onTypingComplete] = useDisplayData(mergedData)\n\n    // ============================ Scroll ============================\n    // Is current scrollTop at the end. User scroll will make this false.\n    const [scrollReachEnd, setScrollReachEnd] = React.useState(true)\n\n    const [updateCount, setUpdateCount] = React.useState(0)\n\n    const onInternalScroll: React.UIEventHandler<HTMLDivElement> = (e) => {\n      const target = e.target as HTMLElement\n\n      setScrollReachEnd(\n        target.scrollHeight -\n          Math.abs(target.scrollTop) -\n          target.clientHeight <=\n          TOLERANCE\n      )\n    }\n\n    React.useEffect(() => {\n      if (autoScroll && listRef.current && scrollReachEnd) {\n        listRef.current.scrollTo({\n          top: listRef.current.scrollHeight,\n        })\n      }\n    }, [updateCount])\n\n    // Always scroll to bottom when data change\n    React.useEffect(() => {\n      if (autoScroll) {\n        // New date come, the origin last one is the second last one\n        const lastItemKey = displayData[displayData.length - 2]?.key\n        const bubbleInst = bubbleRefs.current[lastItemKey!]\n\n        // Auto scroll if last 2 item is visible\n        if (bubbleInst) {\n          const { nativeElement } = bubbleInst\n          const { top, bottom } = nativeElement.getBoundingClientRect()\n          const { top: listTop, bottom: listBottom } =\n            listRef.current!.getBoundingClientRect()\n\n          const isVisible = top < listBottom && bottom > listTop\n          if (isVisible) {\n            setUpdateCount((c) => c + 1)\n            setScrollReachEnd(true)\n          }\n        }\n      }\n    }, [displayData.length])\n\n    // ========================== Outer Ref ===========================\n    React.useImperativeHandle(ref, () => ({\n      nativeElement: listRef.current!,\n      scrollTo: ({ key, offset, behavior = \"smooth\", block }) => {\n        if (typeof offset === \"number\") {\n          // Offset scroll\n          listRef.current!.scrollTo({\n            top: offset,\n            behavior,\n          })\n        } else if (key !== undefined) {\n          // Key scroll\n          const bubbleInst = bubbleRefs.current[key]\n\n          if (bubbleInst) {\n            // Block current auto scrolling\n            const index = displayData.findIndex(\n              (dataItem) => dataItem.key === key\n            )\n            setScrollReachEnd(index === displayData.length - 1)\n\n            // Do native scroll\n            bubbleInst.nativeElement.scrollIntoView({\n              behavior,\n              block,\n            })\n          }\n        }\n      },\n    }))\n\n    // =========================== Context ============================\n    // When bubble content update, we try to trigger `autoScroll` for sync\n    const onBubbleUpdate = useEvent(() => {\n      if (autoScroll) {\n        setUpdateCount((c) => c + 1)\n      }\n    })\n\n    const context = React.useMemo(\n      () => ({\n        onUpdate: onBubbleUpdate,\n      }),\n      []\n    )\n\n    return (\n      <BubbleListContext.Provider value={context}>\n        <div\n          {...props}\n          ref={listRef}\n          className={cn(\"flex flex-col gap-4 overflow-y-auto\", className)}\n          onScroll={onInternalScroll}\n        >\n          {displayData.map(\n            ({\n              key,\n              content,\n              loading,\n              avatar,\n              header,\n              footer,\n              shape,\n              variant,\n              ...bubble\n            }) => (\n              <Bubble\n                {...bubble}\n                key={key}\n                ref={(node) => {\n                  if (node) {\n                    bubbleRefs.current[key] = node\n                  } else {\n                    delete bubbleRefs.current[key]\n                  }\n                }}\n                typing={initialized ? bubble.typing : false}\n                onTypingComplete={() => {\n                  bubble.onTypingComplete?.()\n                  onTypingComplete(key)\n                }}\n              >\n                <>\n                  {avatar}\n                  <BubbleWrapper>\n                    {header}\n                    <BubbleContent\n                      shape={shape}\n                      variant={variant}\n                      loading={loading}\n                    >\n                      {content}\n                    </BubbleContent>\n                    {footer}\n                  </BubbleWrapper>\n                </>\n              </Bubble>\n            )\n          )}\n        </div>\n      </BubbleListContext.Provider>\n    )\n  }\n)\nBubbleList.displayName = \"BubbleList\"\n\nexport { BubbleList, useBubbleList }\n",
      "type": "registry:component",
      "target": "components/aoian-ui/bubble/bubble-list.tsx"
    },
    {
      "path": "registry/aoian-ui/hooks/use-display-data.ts",
      "content": "import * as React from \"react\"\n\nimport { useEvent } from \"@/components/aoian-ui/hooks/use-event\"\nimport { ListItemType } from \"@/components/aoian-ui/hooks/use-list-data\"\n\nexport function useDisplayData(items: ListItemType[]) {\n  const [displayCount, setDisplayCount] = React.useState(items.length)\n\n  const displayList = React.useMemo(\n    () => items.slice(0, displayCount),\n    [items, displayCount]\n  )\n\n  const displayListLastKey = React.useMemo(() => {\n    const lastItem = displayList[displayList.length - 1]\n    return lastItem ? lastItem.key : null\n  }, [displayList])\n\n  // When `items` changed, we replaced with latest one\n  React.useEffect(() => {\n    if (\n      displayList.length &&\n      displayList.every((item, index) => item.key === items[index]?.key)\n    ) {\n      return\n    }\n\n    if (displayList.length === 0) {\n      setDisplayCount(1)\n    } else {\n      // Find diff index\n      for (let i = 0; i < displayList.length; i += 1) {\n        if (displayList[i].key !== items[i]?.key) {\n          setDisplayCount(i)\n          break\n        }\n      }\n    }\n  }, [items])\n\n  // Continue to show if last one finished typing\n  const onTypingComplete = useEvent((key: string | number) => {\n    if (key === displayListLastKey) {\n      setDisplayCount(displayCount + 1)\n    }\n  })\n\n  return [displayList, onTypingComplete] as const\n}\n",
      "type": "registry:hook",
      "target": "components/aoian-ui/hooks/use-display-data.ts"
    },
    {
      "path": "registry/aoian-ui/hooks/use-list-data.ts",
      "content": "import * as React from \"react\"\n\nimport type {\n  BubbleDataType,\n  BubbleListProps,\n  BubbleProps,\n} from \"@/components/aoian-ui/bubble/types\"\n\nexport type ListItemType = ReturnType<typeof useListData>[number]\n\nexport function useListData(\n  items: BubbleListProps[\"items\"],\n  roles?: BubbleListProps[\"roles\"]\n) {\n  const getRoleBubbleProps = React.useCallback(\n    (bubble: BubbleDataType, index: number): Partial<BubbleProps> => {\n      if (typeof roles === \"function\") {\n        return roles(bubble, index)\n      }\n\n      if (roles) {\n        return roles[bubble.role!] || {}\n      }\n\n      return {}\n    },\n    [roles]\n  )\n\n  return React.useMemo(\n    () =>\n      (items || []).map((bubbleData, i) => {\n        const mergedKey = bubbleData.key ?? `preset_${i}`\n\n        return {\n          ...getRoleBubbleProps(bubbleData, i),\n          ...bubbleData,\n          key: mergedKey,\n        }\n      }),\n    [items, getRoleBubbleProps]\n  )\n}\n",
      "type": "registry:hook",
      "target": "components/aoian-ui/hooks/use-list-data.ts"
    },
    {
      "path": "registry/aoian-ui/hooks/use-typed-effect.ts",
      "content": "import * as React from \"react\"\n\n/**\n * Return typed content and typing status when typing is enabled.\n * Or return content directly.\n */\n\nfunction isString(str: any): str is string {\n  return typeof str === \"string\"\n}\n\nexport function useTypedEffect(\n  content: React.ReactNode | object,\n  typingEnabled: boolean,\n  typingStep: number,\n  typingInterval: number\n): [typedContent: React.ReactNode | object, isTyping: boolean] {\n  const [prevContent, setPrevContent] = React.useState<\n    React.ReactNode | object\n  >(\"\")\n  const [typingIndex, setTypingIndex] = React.useState<number>(1)\n\n  const mergedTypingEnabled = typingEnabled && isString(content)\n\n  // Reset typing index when content changed\n  React.useLayoutEffect(() => {\n    setPrevContent(content)\n    if (!mergedTypingEnabled && isString(content)) {\n      setTypingIndex(content.length)\n    } else if (\n      isString(content) &&\n      isString(prevContent) &&\n      content.indexOf(prevContent) !== 0\n    ) {\n      setTypingIndex(1)\n    }\n  }, [content])\n\n  // Start typing\n  React.useEffect(() => {\n    if (mergedTypingEnabled && typingIndex < content.length) {\n      const id = setTimeout(() => {\n        setTypingIndex((prev) => prev + typingStep)\n      }, typingInterval)\n\n      return () => {\n        clearTimeout(id)\n      }\n    }\n  }, [typingIndex, typingEnabled, content])\n\n  const mergedTypingContent = mergedTypingEnabled\n    ? content.slice(0, typingIndex)\n    : content\n\n  return [\n    mergedTypingContent,\n    mergedTypingEnabled && typingIndex < content.length,\n  ]\n}\n",
      "type": "registry:hook",
      "target": "components/aoian-ui/hooks/use-typed-effect.ts"
    },
    {
      "path": "registry/aoian-ui/hooks/use-typing-config.ts",
      "content": "import * as React from \"react\"\n\nimport type { TypingOption } from \"@/components/aoian-ui/bubble/types\"\n\nexport function useTypingConfig(typing?: boolean | TypingOption) {\n  return React.useMemo<\n    [\n      enableTyping: boolean,\n      step: number,\n      interval: number,\n      suffix: React.ReactNode,\n    ]\n  >(() => {\n    if (!typing) {\n      return [false, 0, 0, null]\n    }\n\n    let baseConfig: Required<TypingOption> = {\n      step: 1,\n      interval: 50,\n      // set default suffix is empty\n      suffix: null,\n    }\n\n    if (typeof typing === \"object\") {\n      baseConfig = { ...baseConfig, ...typing }\n    }\n\n    return [true, baseConfig.step, baseConfig.interval, baseConfig.suffix]\n  }, [typing])\n}\n",
      "type": "registry:hook",
      "target": "components/aoian-ui/hooks/use-typing-config.ts"
    },
    {
      "path": "registry/aoian-ui/bubble/types.ts",
      "content": "import type { ReactElement, ReactNode } from \"react\"\n\nexport interface TypingOption {\n  /**\n   * @default 1\n   */\n  step?: number\n  /**\n   * @default 50\n   */\n  interval?: number\n  /**\n   * @default null\n   */\n  suffix?: ReactNode\n}\n\nexport type BubbleProps = {\n  placement?: \"start\" | \"end\"\n  loading?: boolean\n  typing?: boolean | TypingOption\n  onTypingComplete?: VoidFunction\n  className?: string\n  avatarPlaceholder?: boolean\n  messageRender?: (content: string) => ReactNode\n}\n\nexport type BubbleDataType = BubbleProps & {\n  content?: ReactNode\n  key?: string | number\n  role?: string\n  header?: ReactNode\n  footer?: ReactNode\n  avatar?: ReactElement\n  variant?: \"filled\" | \"borderless\" | \"outlined\" | \"shadow\"\n  shape?: \"round\" | \"corner\"\n}\n\ntype RoleType = Partial<Omit<BubbleDataType, \"content\" | \"key\" | \"role\">>\n\ntype RolesType =\n  | Record<string, RoleType>\n  | ((bubbleDataP: BubbleDataType, index: number) => RoleType)\n\nexport interface BubbleListProps extends React.HTMLAttributes<HTMLDivElement> {\n  className?: string\n  items?: BubbleDataType[]\n  autoScroll?: boolean\n  roles?: RolesType\n}\n\nexport interface BubbleRef {\n  nativeElement: HTMLElement\n}\n\nexport interface BubbleListRef {\n  nativeElement: HTMLDivElement\n  scrollTo: (info: {\n    offset?: number\n    key?: string | number\n    behavior?: ScrollBehavior\n    block?: ScrollLogicalPosition\n  }) => void\n}\n",
      "type": "registry:file",
      "target": "components/aoian-ui/bubble/types.ts"
    }
  ]
}